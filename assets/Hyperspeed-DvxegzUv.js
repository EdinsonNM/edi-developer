var e=Object.defineProperty,t=(t,n,s)=>(((t,n,s)=>{n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[n]=s})(t,"symbol"!=typeof n?n+"":n,s),s);import{j as n,W as s,E as i,P as o,S as r,F as a,C as h,V as u,R as l,a as c,B as d,b as m,d as p,e as g,L as f,T as v,I as w,f as P,g as x,h as y,M as b,i as L,k as F,D as M,l as S,m as D}from"./three-vendor-cr-WalWP.js";import{r as T}from"./react-vendor-4VTfIqmk.js";const A={onSpeedUp:()=>{},onSlowDown:()=>{},distortion:"turbulentDistortion",length:400,roadWidth:10,islandWidth:2,lanesPerRoad:4,fov:90,fovSpeedUp:150,speedUp:2,carLightsFade:.4,totalSideLightSticks:20,lightPairsPerRoadWay:40,shoulderLinesWidthPercentage:.05,brokenLinesWidthPercentage:.1,brokenLinesLengthPercentage:.5,lightStickWidth:[.12,.5],lightStickHeight:[1.3,1.7],movingAwaySpeed:[60,80],movingCloserSpeed:[-120,-160],carLightsLength:[12,80],carLightsRadius:[.05,.14],carWidthPercentage:[.3,.5],carShiftX:[-.8,.8],carFloorSeparation:[0,5],colors:{roadColor:526344,islandColor:657930,background:0,shoulderLines:16777215,brokenLines:16777215,leftCars:[14177983,6770850,12732332],rightCars:[242627,941733,3294549],sticks:242627}};function I(e){return.5*Math.sin(e)+.5}const C={uFreq:{value:new g(3,6,10)},uAmp:{value:new g(30,30,20)}},q={uFreq:{value:new u(5,2)},uAmp:{value:new u(25,15)}},k={uFreq:{value:new u(2,3)},uAmp:{value:new u(35,10)}},W={uFreq:{value:new D(4,8,8,1)},uAmp:{value:new D(25,5,10,10)}},z={uFreq:{value:new u(4,8)},uAmp:{value:new u(10,20)},uPowY:{value:new u(20,2)}},U={mountainDistortion:{uniforms:C,getDistortion:"\n      uniform vec3 uAmp;\n      uniform vec3 uFreq;\n      #define PI 3.14159265358979\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      vec3 getDistortion(float progress){\n        float movementProgressFix = 0.02;\n        return vec3( \n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n          nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n          nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n        );\n      }\n    ",getJS:(e,t)=>{const n=.02,s=C.uFreq.value,i=C.uAmp.value,o=new g(Math.cos(e*Math.PI*s.x+t)*i.x-Math.cos(n*Math.PI*s.x+t)*i.x,I(e*Math.PI*s.y+t)*i.y-I(n*Math.PI*s.y+t)*i.y,I(e*Math.PI*s.z+t)*i.z-I(n*Math.PI*s.z+t)*i.z),r=new g(2,2,2),a=new g(0,0,-5);return o.multiply(r).add(a)}},xyDistortion:{uniforms:q,getDistortion:"\n      uniform vec2 uFreq;\n      uniform vec2 uAmp;\n      #define PI 3.14159265358979\n      vec3 getDistortion(float progress){\n        float movementProgressFix = 0.02;\n        return vec3( \n          cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n          sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\n          0.\n        );\n      }\n    ",getJS:(e,t)=>{const n=q.uFreq.value,s=q.uAmp.value,i=new g(Math.cos(e*Math.PI*n.x+t)*s.x-Math.cos(.02*Math.PI*n.x+t)*s.x,Math.sin(e*Math.PI*n.y+t+Math.PI/2)*s.y-Math.sin(.02*Math.PI*n.y+t+Math.PI/2)*s.y,0),o=new g(2,.4,1),r=new g(0,0,-3);return i.multiply(o).add(r)}},LongRaceDistortion:{uniforms:k,getDistortion:"\n      uniform vec2 uFreq;\n      uniform vec2 uAmp;\n      #define PI 3.14159265358979\n      vec3 getDistortion(float progress){\n        float camProgress = 0.0125;\n        return vec3( \n          sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\n          sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\n          0.\n        );\n      }\n    ",getJS:(e,t)=>{const n=.0125,s=k.uFreq.value,i=k.uAmp.value,o=new g(Math.sin(e*Math.PI*s.x+t)*i.x-Math.sin(n*Math.PI*s.x+t)*i.x,Math.sin(e*Math.PI*s.y+t)*i.y-Math.sin(n*Math.PI*s.y+t)*i.y,0),r=new g(1,1,0),a=new g(0,0,-5);return o.multiply(r).add(a)}},turbulentDistortion:{uniforms:W,getDistortion:"\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          cos(PI * progress * uFreq.r + uTime) * uAmp.r +\n          pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\n          -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.0125),\n          getDistortionY(progress) - getDistortionY(0.0125),\n          0.\n        );\n      }\n    ",getJS:(e,t)=>{const n=W.uFreq.value,s=W.uAmp.value,i=e=>Math.cos(Math.PI*e*n.x+t)*s.x+Math.pow(Math.cos(Math.PI*e*n.y+t*(n.y/n.x)),2)*s.y,o=e=>-I(Math.PI*e*n.z+t)*s.z-Math.pow(I(Math.PI*e*n.w+t/(n.z/n.w)),5)*s.w,r=new g(i(e)-i(e+.007),o(e)-o(e+.007),0),a=new g(-2,-5,0),h=new g(0,0,-10);return r.multiply(a).add(h)}},turbulentDistortionStill:{uniforms:W,getDistortion:"\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          cos(PI * progress * uFreq.r) * uAmp.r +\n          pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          -nsin(PI * progress * uFreq.b) * uAmp.b +\n          -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.02),\n          0.\n        );\n      }\n    "},deepDistortionStill:{uniforms:z,getDistortion:"\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      uniform vec2 uPowY;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          sin(progress * PI * uFreq.x) * uAmp.x * 2.\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.05),\n          0.\n        );\n      }\n    "},deepDistortion:{uniforms:z,getDistortion:"\n      uniform vec4 uFreq;\n      uniform vec4 uAmp;\n      uniform vec2 uPowY;\n      float nsin(float val){\n        return sin(val) * 0.5 + 0.5;\n      }\n      #define PI 3.14159265358979\n      float getDistortionX(float progress){\n        return (\n          sin(progress * PI * uFreq.x + uTime) * uAmp.x\n        );\n      }\n      float getDistortionY(float progress){\n        return (\n          pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\n        );\n      }\n      vec3 getDistortion(float progress){\n        return vec3(\n          getDistortionX(progress) - getDistortionX(0.02),\n          getDistortionY(progress) - getDistortionY(0.02),\n          0.\n        );\n      }\n    ",getJS:(e,t)=>{const n=z.uFreq.value,s=z.uAmp.value,i=z.uPowY.value,o=e=>Math.sin(e*Math.PI*n.x+t)*s.x,r=e=>Math.pow(e*i.x,i.y)+Math.sin(e*Math.PI*n.y+t)*s.y,a=new g(o(e)-o(e+.01),r(e)-r(e+.01),0),h=new g(-2,-4,0),u=new g(0,0,-10);return a.multiply(h).add(u)}}},_={uDistortionX:{value:new u(80,3)},uDistortionY:{value:new u(-40,2.5)}};function E(e){return Array.isArray(e)?Math.random()*(e[1]-e[0])+e[0]:Math.random()*e}function O(e){return Array.isArray(e)?e[Math.floor(Math.random()*e.length)]:e}function R(e,t,n=.1,s=.001){let i=(t-e)*n;return Math.abs(i)<s&&(i=t-e),i}class Y{constructor(e,n,s,i,o){t(this,"webgl"),t(this,"options"),t(this,"colors"),t(this,"speed"),t(this,"fade"),t(this,"mesh"),this.webgl=e,this.options=n,this.colors=s,this.speed=i,this.fade=o}init(){const e=this.options,t=new f(new g(0,0,0),new g(0,0,-1)),n=new v(t,40,1,8,!1),s=(new w).copy(n);s.instanceCount=2*e.lightPairsPerRoadWay;const i=e.roadWidth/e.lanesPerRoad,o=[],r=[],a=[];let h;h=Array.isArray(this.colors)?this.colors.map(e=>new P(e)):[new P(this.colors)];for(let c=0;c<e.lightPairsPerRoadWay;c++){const t=E(e.carLightsRadius),n=E(e.carLightsLength),s=E(this.speed);let u=c%e.lanesPerRoad*i-e.roadWidth/2+i/2;const l=E(e.carWidthPercentage)*i;u+=E(e.carShiftX)*i;const d=E(e.carFloorSeparation)+1.3*t,m=-E(e.length);o.push(u-l/2),o.push(d),o.push(m),o.push(u+l/2),o.push(d),o.push(m),r.push(t),r.push(n),r.push(s),r.push(t),r.push(n),r.push(s);const p=O(h);a.push(p.r),a.push(p.g),a.push(p.b),a.push(p.r),a.push(p.g),a.push(p.b)}s.setAttribute("aOffset",new x(new Float32Array(o),3,!1)),s.setAttribute("aMetrics",new x(new Float32Array(r),3,!1)),s.setAttribute("aColor",new x(new Float32Array(a),3,!1));const u=new y({fragmentShader:j,vertexShader:X,transparent:!0,uniforms:Object.assign({uTime:{value:0},uTravelLength:{value:e.length},uFade:{value:this.fade}},this.webgl.fogUniforms,("object"==typeof this.options.distortion?this.options.distortion.uniforms:{})||{})});u.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <getDistortion_vertex>","object"==typeof this.options.distortion?this.options.distortion.getDistortion:"")};const l=new b(s,u);l.frustumCulled=!1,this.webgl.scene.add(l),this.mesh=l}update(e){this.mesh.material.uniforms.uTime&&(this.mesh.material.uniforms.uTime.value=e)}}const j=`\n  #define USE_FOG;\n  ${L.fog_pars_fragment}\n  varying vec3 vColor;\n  varying vec2 vUv; \n  uniform vec2 uFade;\n  void main() {\n    vec3 color = vec3(vColor);\n    float alpha = smoothstep(uFade.x, uFade.y, vUv.x);\n    gl_FragColor = vec4(color, alpha);\n    if (gl_FragColor.a < 0.0001) discard;\n    ${L.fog_fragment}\n  }\n`,X=`\n  #define USE_FOG;\n  ${L.fog_pars_vertex}\n  attribute vec3 aOffset;\n  attribute vec3 aMetrics;\n  attribute vec3 aColor;\n  uniform float uTravelLength;\n  uniform float uTime;\n  varying vec2 vUv; \n  varying vec3 vColor; \n  #include <getDistortion_vertex>\n  void main() {\n    vec3 transformed = position.xyz;\n    float radius = aMetrics.r;\n    float myLength = aMetrics.g;\n    float speed = aMetrics.b;\n\n    transformed.xy *= radius;\n    transformed.z *= myLength;\n\n    transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);\n    transformed.xy += aOffset.xy;\n\n    float progress = abs(transformed.z / uTravelLength);\n    transformed.xyz += getDistortion(progress);\n\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n    vColor = aColor;\n    ${L.fog_vertex}\n  }\n`;class B{constructor(e,n){t(this,"webgl"),t(this,"options"),t(this,"mesh"),this.webgl=e,this.options=n}init(){const e=this.options,t=new F(1,1),n=(new w).copy(t),s=e.totalSideLightSticks;n.instanceCount=s;const i=e.length/(s-1),o=[],r=[],a=[];let h;h=Array.isArray(e.colors.sticks)?e.colors.sticks.map(e=>new P(e)):[new P(e.colors.sticks)];for(let c=0;c<s;c++){const t=E(e.lightStickWidth),n=E(e.lightStickHeight);o.push((c-1)*i*2+i*Math.random());const s=O(h);r.push(s.r),r.push(s.g),r.push(s.b),a.push(t),a.push(n)}n.setAttribute("aOffset",new x(new Float32Array(o),1,!1)),n.setAttribute("aColor",new x(new Float32Array(r),3,!1)),n.setAttribute("aMetrics",new x(new Float32Array(a),2,!1));const u=new y({fragmentShader:G,vertexShader:$,side:M,uniforms:Object.assign({uTravelLength:{value:e.length},uTime:{value:0}},this.webgl.fogUniforms,("object"==typeof e.distortion?e.distortion.uniforms:{})||{})});u.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <getDistortion_vertex>","object"==typeof this.options.distortion?this.options.distortion.getDistortion:"")};const l=new b(n,u);l.frustumCulled=!1,this.webgl.scene.add(l),this.mesh=l}update(e){this.mesh.material.uniforms.uTime&&(this.mesh.material.uniforms.uTime.value=e)}}const $=`\n  #define USE_FOG;\n  ${L.fog_pars_vertex}\n  attribute float aOffset;\n  attribute vec3 aColor;\n  attribute vec2 aMetrics;\n  uniform float uTravelLength;\n  uniform float uTime;\n  varying vec3 vColor;\n  mat4 rotationY( in float angle ) {\n    return mat4(\n      cos(angle),\t\t0,\t\tsin(angle),\t0,\n      0,\t\t        1.0,\t0,\t\t\t0,\n      -sin(angle),\t    0,\t\tcos(angle),\t0,\n      0, \t\t        0,\t\t0,\t\t\t1\n    );\n  }\n  #include <getDistortion_vertex>\n  void main(){\n    vec3 transformed = position.xyz;\n    float width = aMetrics.x;\n    float height = aMetrics.y;\n\n    transformed.xy *= vec2(width, height);\n    float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);\n\n    transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\n    transformed.z += - uTravelLength + time;\n\n    float progress = abs(transformed.z / uTravelLength);\n    transformed.xyz += getDistortion(progress);\n\n    transformed.y += height / 2.;\n    transformed.x += -width / 2.;\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vColor = aColor;\n    ${L.fog_vertex}\n  }\n`,G=`\n  #define USE_FOG;\n  ${L.fog_pars_fragment}\n  varying vec3 vColor;\n  void main(){\n    vec3 color = vec3(vColor);\n    gl_FragColor = vec4(color,1.);\n    ${L.fog_fragment}\n  }\n`;class H{constructor(e,n){t(this,"webgl"),t(this,"options"),t(this,"uTime"),t(this,"leftRoadWay"),t(this,"rightRoadWay"),t(this,"island"),this.webgl=e,this.options=n,this.uTime={value:0}}createPlane(e,t,n){const s=this.options,i=new F(n?s.roadWidth:s.islandWidth,s.length,20,100);let o={uTravelLength:{value:s.length},uColor:{value:new P(n?s.colors.roadColor:s.colors.islandColor)},uTime:this.uTime};n&&(o=Object.assign(o,{uLanes:{value:s.lanesPerRoad},uBrokenLinesColor:{value:new P(s.colors.brokenLines)},uShoulderLinesColor:{value:new P(s.colors.shoulderLines)},uShoulderLinesWidthPercentage:{value:s.shoulderLinesWidthPercentage},uBrokenLinesLengthPercentage:{value:s.brokenLinesLengthPercentage},uBrokenLinesWidthPercentage:{value:s.brokenLinesWidthPercentage}}));const r=new y({fragmentShader:n?N:V,vertexShader:K,side:M,uniforms:Object.assign(o,this.webgl.fogUniforms,("object"==typeof s.distortion?s.distortion.uniforms:{})||{})});r.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <getDistortion_vertex>","object"==typeof this.options.distortion?this.options.distortion.getDistortion:"")};const a=new b(i,r);return a.rotation.x=-Math.PI/2,a.position.z=-s.length/2,a.position.x+=(this.options.islandWidth/2+s.roadWidth/2)*e,this.webgl.scene.add(a),a}init(){this.leftRoadWay=this.createPlane(-1,this.options.roadWidth,!0),this.rightRoadWay=this.createPlane(1,this.options.roadWidth,!0),this.island=this.createPlane(0,this.options.islandWidth,!1)}update(e){this.uTime.value=e}}const J=`\n  #define USE_FOG;\n  varying vec2 vUv; \n  uniform vec3 uColor;\n  uniform float uTime;\n  #include <roadMarkings_vars>\n  ${L.fog_pars_fragment}\n  void main() {\n    vec2 uv = vUv;\n    vec3 color = vec3(uColor);\n    #include <roadMarkings_fragment>\n    gl_FragColor = vec4(color, 1.);\n    ${L.fog_fragment}\n  }\n`,V=J.replace("#include <roadMarkings_fragment>","").replace("#include <roadMarkings_vars>",""),N=J.replace("#include <roadMarkings_fragment>","\n  uv.y = mod(uv.y + uTime * 0.05, 1.);\n  float laneWidth = 1.0 / uLanes;\n  float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\n  float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\n\n  float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));\n  float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);\n\n  brokenLines = mix(brokenLines, sideLines, uv.x);\n").replace("#include <roadMarkings_vars>","\n  uniform float uLanes;\n  uniform vec3 uBrokenLinesColor;\n  uniform vec3 uShoulderLinesColor;\n  uniform float uShoulderLinesWidthPercentage;\n  uniform float uBrokenLinesWidthPercentage;\n  uniform float uBrokenLinesLengthPercentage;\n  highp float random(vec2 co) {\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt = dot(co.xy, vec2(a, b));\n    highp float sn = mod(dt, 3.14);\n    return fract(sin(sn) * c);\n  }\n"),K=`\n  #define USE_FOG;\n  uniform float uTime;\n  ${L.fog_pars_vertex}\n  uniform float uTravelLength;\n  varying vec2 vUv; \n  #include <getDistortion_vertex>\n  void main() {\n    vec3 transformed = position.xyz;\n    vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\n    transformed.x += distortion.x;\n    transformed.z += distortion.y;\n    transformed.y += -1. * distortion.z;  \n    \n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n    ${L.fog_vertex}\n  }\n`;class Q{constructor(e,n){t(this,"container"),t(this,"options"),t(this,"renderer"),t(this,"composer"),t(this,"camera"),t(this,"scene"),t(this,"renderPass"),t(this,"bloomPass"),t(this,"clock"),t(this,"assets"),t(this,"disposed"),t(this,"road"),t(this,"leftCarLights"),t(this,"rightCarLights"),t(this,"leftSticks"),t(this,"fogUniforms"),t(this,"fovTarget"),t(this,"speedUpTarget"),t(this,"speedUp"),t(this,"timeOffset"),t(this,"resizeObserver"),t(this,"animationFrameId"),this.options=n,this.options.distortion||(this.options.distortion={uniforms:_,getDistortion:"\n  #define PI 3.14159265358979\n  uniform vec2 uDistortionX;\n  uniform vec2 uDistortionY;\n  float nsin(float val){\n    return sin(val) * 0.5 + 0.5;\n  }\n  vec3 getDistortion(float progress){\n    progress = clamp(progress, 0., 1.);\n    float xAmp = uDistortionX.r;\n    float xFreq = uDistortionX.g;\n    float yAmp = uDistortionY.r;\n    float yFreq = uDistortionY.g;\n    return vec3( \n      xAmp * nsin(progress * PI * xFreq - PI / 2.),\n      yAmp * nsin(progress * PI * yFreq - PI / 2.),\n      0.\n    );\n  }\n"}),this.container=e,this.renderer=new s({antialias:!1,alpha:!0});const l=e.offsetWidth||window.innerWidth,c=e.offsetHeight||window.innerHeight,d=l/c||1;this.renderer.setSize(l,c,!1),this.renderer.setPixelRatio(window.devicePixelRatio),this.composer=new i(this.renderer),e.appendChild(this.renderer.domElement),this.camera=new o(n.fov,d,.1,1e4),this.camera.position.z=-5,this.camera.position.y=8,this.camera.position.x=0,this.scene=new r,this.scene.background=null;const m=new a(n.colors.background,.2*n.length,500*n.length);this.scene.fog=m,this.fogUniforms={fogColor:{value:m.color},fogNear:{value:m.near},fogFar:{value:m.far}},this.clock=new h,this.assets={},this.disposed=!1,this.road=new H(this,n),this.leftCarLights=new Y(this,n,n.colors.leftCars,n.movingAwaySpeed,new u(0,1-n.carLightsFade)),this.rightCarLights=new Y(this,n,n.colors.rightCars,n.movingCloserSpeed,new u(1,0+n.carLightsFade)),this.leftSticks=new B(this,n),this.fovTarget=n.fov,this.speedUpTarget=0,this.speedUp=0,this.timeOffset=0,this.tick=this.tick.bind(this),this.init=this.init.bind(this),this.setSize=this.setSize.bind(this),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onContextMenu=this.onContextMenu.bind(this),window.addEventListener("resize",this.onWindowResize.bind(this)),"undefined"!=typeof ResizeObserver&&(this.resizeObserver=new ResizeObserver(()=>{this.onWindowResize()}),this.resizeObserver.observe(e))}onWindowResize(){if(this.disposed||!this.renderer||!this.camera)return;const e=this.container.offsetWidth,t=this.container.offsetHeight;e<=0||t<=0||(this.renderer.setSize(e,t),this.camera.aspect=e/t,this.camera.updateProjectionMatrix(),this.composer&&this.composer.setSize(e,t))}initPasses(){this.renderPass=new l(this.scene,this.camera),this.bloomPass=new c(this.camera,new d({luminanceThreshold:.2,luminanceSmoothing:0,resolutionScale:1}));const e=new c(this.camera,new m({preset:p.MEDIUM}));this.renderPass.renderToScreen=!1,this.bloomPass.renderToScreen=!1,e.renderToScreen=!0,this.composer.addPass(this.renderPass),this.composer.addPass(this.bloomPass),this.composer.addPass(e)}loadAssets(){const e=this.assets;return new Promise(t=>{const n=new S(t),s=new Image,i=new Image;e.smaa={},s.addEventListener("load",function(){e.smaa.search=this,n.itemEnd("smaa-search")}),i.addEventListener("load",function(){e.smaa.area=this,n.itemEnd("smaa-area")}),n.itemStart("smaa-search"),n.itemStart("smaa-area"),s.src=m.searchImageDataURL,i.src=m.areaImageDataURL})}init(){this.initPasses();const e=this.options;this.road.init(),this.leftCarLights.init(),this.leftCarLights.mesh.position.setX(-e.roadWidth/2-e.islandWidth/2),this.rightCarLights.init(),this.rightCarLights.mesh.position.setX(e.roadWidth/2+e.islandWidth/2),this.leftSticks.init(),this.leftSticks.mesh.position.setX(-(e.roadWidth+e.islandWidth/2)),this.container.addEventListener("mousedown",this.onMouseDown),this.container.addEventListener("mouseup",this.onMouseUp),this.container.addEventListener("mouseout",this.onMouseUp),this.container.addEventListener("touchstart",this.onTouchStart,{passive:!0}),this.container.addEventListener("touchend",this.onTouchEnd,{passive:!0}),this.container.addEventListener("touchcancel",this.onTouchEnd,{passive:!0}),this.container.addEventListener("contextmenu",this.onContextMenu),this.tick()}onMouseDown(e){this.options.onSpeedUp&&this.options.onSpeedUp(e),this.fovTarget=this.options.fovSpeedUp,this.speedUpTarget=this.options.speedUp}onMouseUp(e){this.options.onSlowDown&&this.options.onSlowDown(e),this.fovTarget=this.options.fov,this.speedUpTarget=0}onTouchStart(e){this.options.onSpeedUp&&this.options.onSpeedUp(e),this.fovTarget=this.options.fovSpeedUp,this.speedUpTarget=this.options.speedUp}onTouchEnd(e){this.options.onSlowDown&&this.options.onSlowDown(e),this.fovTarget=this.options.fov,this.speedUpTarget=0}onContextMenu(e){e.preventDefault()}update(e){const t=Math.exp(60*Math.log2(.9)*e);this.speedUp+=R(this.speedUp,this.speedUpTarget,t,1e-5),this.timeOffset+=this.speedUp*e;const n=this.clock.elapsedTime+this.timeOffset;this.rightCarLights.update(n),this.leftCarLights.update(n),this.leftSticks.update(n),this.road.update(n);let s=!1;const i=R(this.camera.fov,this.fovTarget,t);if(0!==i&&(this.camera.fov+=i*e*6,s=!0),"object"==typeof this.options.distortion&&this.options.distortion.getJS){const e=this.options.distortion.getJS(.025,n);this.camera.lookAt(new g(this.camera.position.x+e.x,this.camera.position.y+e.y,this.camera.position.z+e.z)),s=!0}s&&this.camera.updateProjectionMatrix()}render(e){this.composer.render(e)}dispose(){var e;if(this.disposed=!0,void 0!==this.animationFrameId&&(cancelAnimationFrame(this.animationFrameId),this.animationFrameId=void 0),this.resizeObserver&&(this.resizeObserver.disconnect(),this.resizeObserver=void 0),this.renderer){const t=this.renderer.domElement;t&&t.parentNode===this.container&&this.container.removeChild(t);const n=this.renderer.getContext();if(n){const t=null==(e=n.getExtension)?void 0:e.call(n,"WEBGL_lose_context");t&&t.loseContext()}this.renderer.dispose(),this.renderer=null}this.composer&&(this.composer.dispose(),this.composer=null),this.scene&&(this.scene.clear(),this.scene=null),window.removeEventListener("resize",this.onWindowResize.bind(this)),this.container&&(this.container.removeEventListener("mousedown",this.onMouseDown),this.container.removeEventListener("mouseup",this.onMouseUp),this.container.removeEventListener("mouseout",this.onMouseUp),this.container.removeEventListener("touchstart",this.onTouchStart),this.container.removeEventListener("touchend",this.onTouchEnd),this.container.removeEventListener("touchcancel",this.onTouchEnd),this.container.removeEventListener("contextmenu",this.onContextMenu))}setSize(e,t,n){this.composer&&!this.disposed&&this.composer.setSize(e,t,n)}tick(){if(this.disposed||!this)return;if(function(e,t){const n=e.domElement,s=n.clientWidth,i=n.clientHeight,o=n.width!==s||n.height!==i;return o&&t(s,i,!1),o}(this.renderer,this.setSize)){const e=this.renderer.domElement;this.camera.aspect=e.clientWidth/e.clientHeight,this.camera.updateProjectionMatrix()}const e=this.clock.getDelta();this.render(e),this.update(e),this.animationFrameId=requestAnimationFrame(this.tick)}}const Z=({effectOptions:e={}})=>{const t={...A,...e},s=T.useRef(null),i=T.useRef(null);return T.useEffect(()=>{if(i.current){i.current.dispose(),i.current=null;const e=s.current;if(e)for(;e.firstChild;)e.removeChild(e.firstChild)}const e=s.current;if(!e)return;const n={...t};"string"==typeof n.distortion&&(n.distortion=U[n.distortion]);const o=new Q(e,n);i.current=o;const r=()=>{o&&!o.disposed&&o.onWindowResize()};return requestAnimationFrame(()=>{requestAnimationFrame(r)}),o.loadAssets().then(()=>{o.disposed||(o.init(),r())}),()=>{if(i.current&&(i.current.dispose(),i.current=null),e)for(;e.firstChild;)e.removeChild(e.firstChild)}},[t]),n.jsx("div",{id:"lights",className:"w-full h-full",ref:s})};export{Z as default};
